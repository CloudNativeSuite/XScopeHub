// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ops_case.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCase = `-- name: CreateCase :one
INSERT INTO ops_case (tenant_id, title, severity, status, resource_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING case_id, tenant_id, title, severity::text AS severity, status, resource_id, created_at, updated_at, labels
`

type CreateCaseParams struct {
	TenantID   int64
	Title      string
	Severity   interface{}
	Status     string
	ResourceID pgtype.Int8
}

type CreateCaseRow struct {
	CaseID     pgtype.UUID
	TenantID   int64
	Title      string
	Severity   string
	Status     string
	ResourceID pgtype.Int8
	CreatedAt  pgtype.Timestamptz
	UpdatedAt  pgtype.Timestamptz
	Labels     []byte
}

func (q *Queries) CreateCase(ctx context.Context, arg CreateCaseParams) (CreateCaseRow, error) {
	row := q.db.QueryRow(ctx, createCase,
		arg.TenantID,
		arg.Title,
		arg.Severity,
		arg.Status,
		arg.ResourceID,
	)
	var i CreateCaseRow
	err := row.Scan(
		&i.CaseID,
		&i.TenantID,
		&i.Title,
		&i.Severity,
		&i.Status,
		&i.ResourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Labels,
	)
	return i, err
}

const insertOutbox = `-- name: InsertOutbox :exec
INSERT INTO outbox (aggregate, aggregate_id, topic, payload)
VALUES ($1, $2, $3, $4)
`

type InsertOutboxParams struct {
	Aggregate   pgtype.Text
	AggregateID pgtype.Text
	Topic       pgtype.Text
	Payload     []byte
}

func (q *Queries) InsertOutbox(ctx context.Context, arg InsertOutboxParams) error {
	_, err := q.db.Exec(ctx, insertOutbox,
		arg.Aggregate,
		arg.AggregateID,
		arg.Topic,
		arg.Payload,
	)
	return err
}

const listUnpublishedOutbox = `-- name: ListUnpublishedOutbox :many
SELECT id, aggregate, aggregate_id, topic, payload, created_at
FROM outbox
WHERE published = FALSE
ORDER BY id
LIMIT $1
FOR UPDATE SKIP LOCKED
`

type ListUnpublishedOutboxRow struct {
	ID          int64
	Aggregate   pgtype.Text
	AggregateID pgtype.Text
	Topic       pgtype.Text
	Payload     []byte
	CreatedAt   pgtype.Timestamptz
}

func (q *Queries) ListUnpublishedOutbox(ctx context.Context, limit int32) ([]ListUnpublishedOutboxRow, error) {
	rows, err := q.db.Query(ctx, listUnpublishedOutbox, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUnpublishedOutboxRow
	for rows.Next() {
		var i ListUnpublishedOutboxRow
		if err := rows.Scan(
			&i.ID,
			&i.Aggregate,
			&i.AggregateID,
			&i.Topic,
			&i.Payload,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markOutboxPublished = `-- name: MarkOutboxPublished :exec
UPDATE outbox SET published = TRUE, published_at = now()
WHERE id = ANY($1::bigint[])
`

func (q *Queries) MarkOutboxPublished(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, markOutboxPublished, dollar_1)
	return err
}
